"""
Servicio RAG (Retrieval-Augmented Generation) para el chat
"""
from typing import List, Dict, Optional
from app.database.connection import engine
from sqlalchemy import text
import openai
from app.core.config import settings

class RAGService:
    """Servicio RAG para recuperar informaci√≥n relevante"""
    
    def __init__(self):
        self.openai_client = openai.OpenAI(api_key=settings.openai_api_key)
    
    async def search_knowledge(self, query: str, limit: int = 3) -> List[Dict]:
        """Buscar informaci√≥n relevante en la base de conocimiento"""
        try:
            with engine.connect() as conn:
                # B√∫squeda simple por palabras clave en t√≠tulo y contenido
                result = conn.execute(
                    text("""
                        SELECT title, content, category 
                        FROM rag_knowledge 
                        WHERE LOWER(title) LIKE LOWER(:query) 
                           OR LOWER(content) LIKE LOWER(:query)
                        ORDER BY 
                            CASE 
                                WHEN LOWER(title) LIKE LOWER(:query) THEN 1
                                ELSE 2
                            END
                        LIMIT :limit
                    """),
                    {"query": f"%{query}%", "limit": limit}
                )
                
                knowledge_items = []
                for row in result:
                    knowledge_items.append({
                        "title": row[0],
                        "content": row[1],
                        "category": row[2]
                    })
                
                return knowledge_items
                
        except Exception as e:
            print(f"‚ùå Error buscando conocimiento: {e}")
            return []
    
    async def search_products(self, query: str, limit: int = 5) -> List[Dict]:
        """Buscar productos relevantes"""
        try:
            with engine.connect() as conn:
                result = conn.execute(
                    text("""
                        SELECT id, title, description, price, category, stock 
                        FROM products 
                        WHERE active = true 
                          AND (LOWER(title) LIKE LOWER(:query) 
                               OR LOWER(description) LIKE LOWER(:query)
                               OR LOWER(category) LIKE LOWER(:query))
                        ORDER BY 
                            CASE 
                                WHEN LOWER(title) LIKE LOWER(:query) THEN 1
                                WHEN LOWER(category) LIKE LOWER(:query) THEN 2
                                ELSE 3
                            END
                        LIMIT :limit
                    """),
                    {"query": f"%{query}%", "limit": limit}
                )
                
                products = []
                for row in result:
                    products.append({
                        "id": row[0],
                        "title": row[1],
                        "description": row[2],
                        "price": float(row[3]),
                        "category": row[4],
                        "stock": row[5]
                    })
                
                return products
                
    except Exception as e:
            print(f"‚ùå Error buscando productos: {e}")
            return []
    
    async def generate_response(self, user_message: str, context: List[Dict] = None) -> str:
        """Generar respuesta usando OpenAI con contexto RAG"""
        try:
            # Buscar informaci√≥n relevante
            knowledge = await self.search_knowledge(user_message)
            products = await self.search_products(user_message)
            
            # Construir contexto
            context_text = ""
            if knowledge:
                context_text += "üìö Informaci√≥n de la tienda:\n"
                for item in knowledge:
                    context_text += f"- {item['title']}: {item['content']}\n"
                context_text += "\n"
            
            if products:
                context_text += "üõçÔ∏è Productos disponibles:\n"
                for product in products[:3]:  # Limitar a 3 productos
                    context_text += f"- {product['title']}: ${product['price']} ({product['category']})\n"
                context_text += "\n"
            
            # Prompt para OpenAI
            system_prompt = f"""Eres un asistente virtual de una tienda online. 
            Usa la siguiente informaci√≥n para responder de manera √∫til y amigable:

            {context_text}

            Instrucciones:
            - Responde en espa√±ol
            - S√© amigable y profesional
            - Si hay productos relevantes, menci√≥nalos
            - Si no tienes informaci√≥n espec√≠fica, ofrece ayuda general
            - Mant√©n las respuestas concisas pero √∫tiles
            - Si el usuario pregunta sobre precios, env√≠os, devoluciones, etc., usa la informaci√≥n proporcionada
            """
            
            response = self.openai_client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_message}
                ],
                max_tokens=300,
                temperature=0.7
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            print(f"‚ùå Error generando respuesta RAG: {e}")
            return f"Lo siento, no pude procesar tu consulta en este momento. ¬øPodr√≠as reformular tu pregunta?"
    
    async def get_recommendations(self, user_message: str) -> List[Dict]:
        """Obtener recomendaciones de productos basadas en el mensaje"""
        try:
            products = await self.search_products(user_message, limit=5)
            return products
        except Exception as e:
            print(f"‚ùå Error obteniendo recomendaciones: {e}")
            return []

# Instancia global del servicio RAG
rag_service = RAGService()

# Funciones de compatibilidad para el c√≥digo existente
async def rag_answer(query: str, db=None, context: List[Dict] = None) -> str:
    """Funci√≥n de compatibilidad para rag_answer"""
    return await rag_service.generate_response(query, context)

async def advanced_rag_answer(query: str, db=None, context: List[Dict] = None) -> Dict:
    """Funci√≥n de compatibilidad para advanced_rag_answer"""
    try:
        response = await rag_service.generate_response(query, context)
        recommendations = await rag_service.get_recommendations(query)
        
        return {
            "response": response,
            "recommendations": recommendations,
            "context": context or []
        }
    except Exception as e:
        return {
            "response": f"Lo siento, no pude procesar tu consulta: {str(e)}",
            "recommendations": [],
            "context": []
        }